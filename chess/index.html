<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Stockfish Chess Calculator</title>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.css">
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.12.1/chess.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.js"></script>

  <style>
    *{box-sizing:border-box;font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif}
    body{margin:0;padding:24px;background:radial-gradient(circle at top,#2b2924 0,#141414 55%,#0b0b0b 100%);color:#f9fafb}
    .app{max-width:1320px;margin:0 auto;display:flex;gap:24px;align-items:flex-start;justify-content:center}
    .board-shell{background:#262421;padding:18px;border-radius:12px;box-shadow:0 18px 40px rgba(0,0,0,.7)}
    .board-with-bar{display:flex;gap:12px;align-items:stretch}
    #board{width:640px;max-width:100%}
    .eval-bar{width:26px;border-radius:999px;background:#111;border:1px solid #444;box-shadow:0 0 0 1px rgba(0,0,0,.7);position:relative;overflow:hidden}
    .eval-bar-white{position:absolute;left:0;right:0;bottom:0;height:50%;background:#f9fafb}
    .panel{width:380px;background:#14161a;color:#f9fafb;border-radius:14px;padding:18px 18px 16px;display:flex;flex-direction:column;gap:14px;box-shadow:0 16px 32px rgba(0,0,0,.65);border:1px solid rgba(148,163,184,.25)}
    .panel-header{display:flex;align-items:center;justify-content:space-between;margin-bottom:4px}
    .panel-title{font-size:18px;font-weight:600;letter-spacing:.03em;text-transform:uppercase;color:#e5e7eb}
    .panel-sub{font-size:11px;text-transform:uppercase;letter-spacing:.12em;color:#9ca3af}
    .top-buttons{display:flex;flex-wrap:wrap;gap:8px;margin-top:6px}
    button{border:none;border-radius:7px;padding:7px 13px;font-size:13px;cursor:pointer;background:#1f2933;color:#e5e7eb;transition:transform .06s,box-shadow .06s,background .15s}
    button.primary{background:#1b7c3f}
    button:disabled{opacity:.5;cursor:default}
    button:hover:not(:disabled){background:#25323f;transform:translateY(-1px);box-shadow:0 3px 8px rgba(0,0,0,.5)}
    button.primary:hover:not(:disabled){background:#1f8f48}
    .field-group{display:flex;flex-direction:column;gap:5px}
    .field-label{font-size:12px;font-weight:600;color:#cbd5f5;text-transform:uppercase;letter-spacing:.08em}
    .fen-input{width:100%;padding:7px 9px;border-radius:7px;border:1px solid #374151;font-size:13px;background:#030712;color:#e5e7eb}
    .fen-input:focus{outline:none;border-color:#22c55e;box-shadow:0 0 0 1px rgba(34,197,94,.35)}
    .row{display:flex;gap:10px;flex-wrap:wrap}
    .radio-group,.castle-group{flex:1;background:#050816;padding:8px 9px;border-radius:9px;display:flex;flex-direction:column;gap:5px;font-size:12px;border:1px solid #1f2937}
    .section-title{font-size:11px;text-transform:uppercase;letter-spacing:.09em;color:#9ca3af;margin-bottom:2px}
    .radio-line,.castle-line{display:flex;align-items:center;gap:7px}
    .radio-line input,.castle-line input{accent-color:#22c55e}
    .calculate-row{display:flex;align-items:center;gap:10px;margin-top:2px}
    .mode-group{flex:1;background:#050816;padding:8px 9px;border-radius:9px;display:flex;justify-content:space-around;font-size:12px;border:1px solid #1f2937}
    .output-row{display:flex;gap:9px;flex-wrap:wrap}
    .output-field{flex:1;min-width:100px;background:#050816;padding:8px 9px;border-radius:9px;display:flex;flex-direction:column;gap:4px;font-size:12px;border:1px solid #1f2937}
    .output-value{background:#020617;border-radius:6px;padding:5px 7px;font-size:14px;min-height:24px;color:#e5e7eb}
    .pv-box{background:#050816;padding:8px 9px;border-radius:9px;font-size:12px;border:1px solid #1f2937}
    .pv-value{background:#020617;border-radius:6px;padding:5px 7px;min-height:34px;font-size:13px;line-height:1.35;overflow-wrap:anywhere;color:#e5e7eb}
    .time-row{display:flex;align-items:center;gap:8px;font-size:12px;margin-top:2px}
    .time-row input{width:64px;padding:5px 7px;border-radius:7px;border:1px solid #374151;font-size:13px;background:#030712;color:#e5e7eb}
    .time-row input:focus{outline:none;border-color:#22c55e;box-shadow:0 0 0 1px rgba(34,197,94,.35)}
    .status-line{font-size:11px;color:#9ca3af;min-height:14px;margin-top:2px}
    .highlight-square{position:relative}
    .highlight-square::before{content:'';position:absolute;inset:0;background:rgba(234,179,8,.55);pointer-events:none;z-index:1}
    .white-1e1d7{background-color:#f0d9b5}
    .black-3c85d{background-color:#b58863}
    @media (max-width:1100px){
      .app{flex-direction:column;align-items:center}
      .panel{width:100%;max-width:460px}
      .board-shell{width:100%;max-width:640px}
      #board{width:100%}
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="board-shell">
      <div class="board-with-bar">
        <div id="board"></div>
        <div class="eval-bar">
          <div id="evalBarWhite" class="eval-bar-white"></div>
        </div>
      </div>
    </div>

    <div class="panel">
      <div class="panel-header">
        <div>
          <div class="panel-title">ENGINE PANEL</div>
          <div class="panel-sub">STOCKFISH ANALYSIS</div>
        </div>
      </div>

      <div class="top-buttons">
        <button id="btnStart">Start Pos</button>
        <button id="btnSetFen">Set FEN</button>
        <button id="btnClear">Clear</button>
        <button id="btnFlip">Flip</button>
      </div>

      <div class="field-group">
        <div class="field-label">FEN</div>
        <input id="fenInput" class="fen-input" type="text" spellcheck="false">
      </div>

      <div class="row">
        <div class="radio-group">
          <div class="section-title">Side to move</div>
          <label class="radio-line">
            <input type="radio" name="side" id="sideWhite" value="w">
            <span>White to move</span>
          </label>
          <label class="radio-line">
            <input type="radio" name="side" id="sideBlack" value="b">
            <span>Black to move</span>
          </label>
          <label class="radio-line">
            <input type="checkbox" id="autoSwitch">
            <span>Auto-switch side</span>
          </label>
        </div>

        <div class="castle-group">
          <div class="section-title">Castling rights</div>
          <label class="castle-line">
            <input type="checkbox" id="castleWK">
            <span>White O-O</span>
          </label>
          <label class="castle-line">
            <input type="checkbox" id="castleWQ">
            <span>White O-O-O</span>
          </label>
          <label class="castle-line">
            <input type="checkbox" id="castleBK">
            <span>Black O-O</span>
          </label>
          <label class="castle-line">
            <input type="checkbox" id="castleBQ">
            <span>Black O-O-O</span>
          </label>
        </div>
      </div>

      <div class="calculate-row">
        <button id="btnCalculate" class="primary">Calculate position</button>
        <div class="mode-group">
          <label class="radio-line">
            <input type="radio" name="mode" id="modeShow" value="show" checked>
            <span>Show move</span>
          </label>
          <label class="radio-line">
            <input type="radio" name="mode" id="modeMake" value="make">
            <span>Make move</span>
          </label>
        </div>
      </div>

      <div class="output-row">
        <div class="output-field">
          <div class="section-title">Best move</div>
          <div id="bestMoveValue" class="output-value"></div>
        </div>
        <div class="output-field">
          <div class="section-title">Score</div>
          <div id="scoreValue" class="output-value"></div>
        </div>
        <div class="output-field">
          <div class="section-title">Depth</div>
          <div id="depthValue" class="output-value"></div>
        </div>
      </div>

      <div class="pv-box">
        <div class="section-title">PV</div>
        <div id="pvValue" class="pv-value"></div>
      </div>

      <div class="pv-box">
        <div class="section-title">Description</div>
        <div id="descriptionValue" class="pv-value"></div>
      </div>

      <div class="time-row">
        <span>Time to think (seconds):</span>
        <input id="timeInput" type="number" min="0.1" step="0.1" value="1">
      </div>

      <div class="time-row">
        <label class="radio-line">
          <input type="checkbox" id="eloEnable">
          <span>Limit strength (Elo):</span>
        </label>
        <input id="eloInput" type="number" min="600" max="3200" step="50" value="1800">
      </div>

      <div id="statusLine" class="status-line"></div>
    </div>
  </div>

  <script>
    var board;
    var engine;
    var isCalculating=false;
    var lastSearchFen="";
    var shouldToggleAfterSnap=false;

    var pieceImages={
      wP:"https://chess-bot.com/online_calculator/img/chesspieces/wikipedia/wP.png",
      wR:"https://chess-bot.com/online_calculator/img/chesspieces/wikipedia/wR.png",
      wN:"https://chess-bot.com/online_calculator/img/chesspieces/wikipedia/wN.png",
      wB:"https://chess-bot.com/online_calculator/img/chesspieces/wikipedia/wB.png",
      wQ:"https://chess-bot.com/online_calculator/img/chesspieces/wikipedia/wQ.png",
      wK:"https://chess-bot.com/online_calculator/img/chesspieces/wikipedia/wK.png",
      bP:"https://chess-bot.com/online_calculator/img/chesspieces/wikipedia/bP.png",
      bR:"https://chess-bot.com/online_calculator/img/chesspieces/wikipedia/bR.png",
      bN:"https://chess-bot.com/online_calculator/img/chesspieces/wikipedia/bN.png",
      bB:"https://chess-bot.com/online_calculator/img/chesspieces/wikipedia/bB.png",
      bQ:"https://chess-bot.com/online_calculator/img/chesspieces/wikipedia/bQ.png",
      bK:"https://chess-bot.com/online_calculator/img/chesspieces/wikipedia/bK.png"
    };

    function clearHighlights(){ $("#board .square-55d63").removeClass("highlight-square"); }
    function highlightMove(from,to){
      clearHighlights();
      $("#board .square-"+from).addClass("highlight-square");
      $("#board .square-"+to).addClass("highlight-square");
    }

    function getSideFromControls(){ return $("input[name='side']:checked").val() || "w"; }
    function isAutoSwitchEnabled(){ return $("#autoSwitch").is(":checked"); }

    function getCastlingFromControls(){
      var c="";
      if($("#castleWK").is(":checked"))c+="K";
      if($("#castleWQ").is(":checked"))c+="Q";
      if($("#castleBK").is(":checked"))c+="k";
      if($("#castleBQ").is(":checked"))c+="q";
      return c===""?"-":c;
    }

    function setControlsFromFen(fen){
      var parts=fen.trim().split(/\s+/);
      if(parts.length<3)return;
      var side=parts[1];
      var castling=parts[2];
      $("#sideWhite").prop("checked",side==="w");
      $("#sideBlack").prop("checked",side==="b");
      $("#castleWK").prop("checked",castling.indexOf("K")!==-1);
      $("#castleWQ").prop("checked",castling.indexOf("Q")!==-1);
      $("#castleBK").prop("checked",castling.indexOf("k")!==-1);
      $("#castleBQ").prop("checked",castling.indexOf("q")!==-1);
    }

    function boardPositionToFenPieces(pos){
      var files="abcdefgh";
      var rows=[];
      for(var rank=8;rank>=1;rank--){
        var empty=0,row="";
        for(var fi=0;fi<8;fi++){
          var square=files[fi]+rank;
          var piece=pos[square];
          if(!piece){ empty++; }
          else{
            if(empty>0){ row+=empty; empty=0; }
            var color=piece.charAt(0),type=piece.charAt(1);
            row+=color==="w"?type:type.toLowerCase();
          }
        }
        if(empty>0)row+=empty;
        rows.push(row);
      }
      return rows.join("/");
    }

    function getCurrentFen(){
      var pos=board.position();
      var pieces=boardPositionToFenPieces(pos);
      var side=getSideFromControls();
      var castling=getCastlingFromControls();
      return pieces+" "+side+" "+castling+" - 0 1";
    }

    function syncFenInputFromBoard(){
      var fen=getCurrentFen();
      $("#fenInput").val(fen);
    }

    function loadFenIntoBoardAndControls(fen){
      var gameTmp=new Chess();
      try{ if(!gameTmp.load(fen)) return false; }catch(e){ return false; }
      var boardArr=gameTmp.board();
      var pos={},files="abcdefgh";
      for(var rank=0;rank<8;rank++){
        for(var file=0;file<8;file++){
          var piece=boardArr[rank][file];
          if(!piece)continue;
          var square=files[file]+(8-rank);
          var code=(piece.color==="w"?"w":"b")+piece.type.toUpperCase();
          pos[square]=code;
        }
      }
      board.position(pos);
      var normalizedFen=gameTmp.fen();
      $("#fenInput").val(normalizedFen);
      setControlsFromFen(normalizedFen);
      return true;
    }

    function setEvalBar(whitePercent){
      var p=Math.max(0,Math.min(100,whitePercent));
      $("#evalBarWhite").css("height",p+"%");
    }

    function convertPvToSan(pvString,fen){
      if(!pvString)return"";
      var moves=pvString.trim().split(/\s+/);
      var temp;
      try{ temp=new Chess(fen); }catch(e){ return pvString; }
      var sanMoves=[];
      for(var i=0;i<moves.length;i++){
        var uci=moves[i];
        if(uci.length<4)continue;
        var from=uci.slice(0,2),to=uci.slice(2,4),promo=uci.length>4?uci.slice(4):undefined;
        var move=temp.move({from:from,to:to,promotion:promo});
        if(!move)break;
        sanMoves.push(move.san);
      }
      return sanMoves.join(" ");
    }

    function updateEvalBarFromScore(scoreType,whiteValue){
      if(scoreType==="cp"){
        var pawns=whiteValue/100,maxP=5;
        if(pawns>maxP)pawns=maxP;
        if(pawns<-maxP)pawns=-maxP;
        var whitePercent=50+(pawns/maxP)*50;
        setEvalBar(whitePercent);
      }else{
        setEvalBar(whiteValue>0?99:1);
      }
    }

    function pieceNameDe(type){
      if(type==="q")return"Dame";
      if(type==="r")return"Turm";
      if(type==="b")return"Läufer";
      if(type==="n")return"Springer";
      if(type==="k")return"König";
      if(type==="p")return"Bauer";
      return"type";
    }

    function pieceValue(type){
      if(type==="p")return 1;
      if(type==="n")return 3;
      if(type==="b")return 3;
      if(type==="r")return 5;
      if(type==="q")return 9;
      if(type==="k")return 0;
      return 0;
    }

    function materialSnapshot(game){
      var b=game.board();
      var w=0,bk=0;
      for(var r=0;r<8;r++){
        for(var f=0;f<8;f++){
          var p=b[r][f];
          if(!p)continue;
          var v=pieceValue(p.type);
          if(p.color==="w")w+=v; else bk+=v;
        }
      }
      return {w:w,b:bk};
    }

    function isCenterSquare(sq){
      return sq==="d4"||sq==="e4"||sq==="d5"||sq==="e5"||sq==="c4"||sq==="c5"||sq==="f4"||sq==="f5";
    }

    function isDevelopmentMove(move){
      if(!move||!move.piece)return false;
      if(move.piece!=="n" && move.piece!=="b")return false;
      var fromRank=move.from.charAt(1);
      var color=move.color;
      if(color==="w" && fromRank!=="1")return false;
      if(color==="b" && fromRank!=="8")return false;
      return true;
    }

    function isCentralPawnPush(move){
      if(!move||move.piece!=="p")return false;
      return move.to==="e4"||move.to==="d4"||move.to==="e5"||move.to==="d5";
    }

    function attackedHighValueTarget(gameAfter,move){
      try{
        var list=gameAfter.moves({square:move.to,verbose:true});
        var best=null;
        var bestV=0;
        for(var i=0;i<list.length;i++){
          var m=list[i];
          if(!m.captured)continue;
          var v=pieceValue(m.captured);
          if(v>bestV){
            bestV=v;
            best=m;
          }
        }
        if(best && bestV>0){
          return {captured:best.captured,to:best.to,value:bestV};
        }
      }catch(e){}
      return null;
    }

    function describeOneMoveWhy(gameBefore,uci){
      if(!uci||uci.length<4)return null;
      var from=uci.slice(0,2),to=uci.slice(2,4),promo=uci.length>4?uci.slice(4):undefined;

      var inCheckBefore=false;
      try{ inCheckBefore=gameBefore.in_check(); }catch(e){ inCheckBefore=false; }

      var matBefore=materialSnapshot(gameBefore);
      var moveObj=gameBefore.move({from:from,to:to,promotion:promo});
      if(!moveObj)return null;

      var colorName=moveObj.color==="w"?"Weiß":"Schwarz";
      var reasons=[];

      if(inCheckBefore)reasons.push("pariert das Schach und stabilisiert den König");

      if(moveObj.flags && (moveObj.flags.indexOf("k")!==-1 || moveObj.flags.indexOf("q")!==-1)){
        reasons.push("rochiert, um den König zu sichern und den Turm ins Spiel zu bringen");
      }

      if(moveObj.flags && (moveObj.flags.indexOf("c")!==-1 || moveObj.flags.indexOf("e")!==-1)){
        var cap=moveObj.captured?pieceNameDe(moveObj.captured):"Figur";
        reasons.push("schlägt eine "+cap+", um Material zu gewinnen oder eine Drohung zu entfernen");
      }

      if(moveObj.promotion){
        reasons.push("verwandelt, um eine starke Figur zu bekommen und den Vorteil zu erhöhen");
      }

      var givesMate=false,givesCheck=false;
      try{
        givesMate=gameBefore.in_checkmate();
        givesCheck=gameBefore.in_check();
      }catch(e){
        givesMate=false;givesCheck=false;
      }

      if(givesMate){
        reasons.unshift("setzt matt, weil der gegnerische König keine sinnvolle Verteidigung mehr hat");
      }else if(givesCheck){
        reasons.unshift("gibt Schach, um Tempo zu gewinnen und den Gegner zu einer Reaktion zu zwingen");
      }

      if(isCentralPawnPush(moveObj)){
        reasons.push("besetzt das Zentrum, gewinnt Raum und erleichtert die Figurenentwicklung");
      }

      if(isDevelopmentMove(moveObj)){
        reasons.push("entwickelt eine Figur und verbessert die Aktivität");
      }

      if(isCenterSquare(moveObj.to) && moveObj.piece!=="p"){
        reasons.push("nimmt Einfluss im Zentrum und erhöht den Druck");
      }

      var matAfter=materialSnapshot(gameBefore);
      var side=moveObj.color;
      var beforeDiff=(side==="w"?(matBefore.w-matBefore.b):(matBefore.b-matBefore.w));
      var afterDiff=(side==="w"?(matAfter.w-matAfter.b):(matAfter.b-matAfter.w));
      if(afterDiff>beforeDiff)reasons.push("verbessert die Materialbilanz");
      if(afterDiff<beforeDiff){
        if(givesCheck || reasons.indexOf("rochiert, um den König zu sichern und den Turm ins Spiel zu bringen")!==-1){
          reasons.push("nimmt dafür bewusst Material in Kauf, um Initiative/Angriff zu bekommen");
        }else{
          reasons.push("nimmt Material in Kauf, um langfristige Kompensation zu erhalten");
        }
      }

      var target=attackedHighValueTarget(gameBefore,moveObj);
      if(target && !(moveObj.flags && (moveObj.flags.indexOf("c")!==-1 || moveObj.flags.indexOf("e")!==-1))){
        reasons.push("setzt Druck auf eine "+pieceNameDe(target.captured)+" und kann Material gewinnen");
      }

      if(reasons.length===0){
        reasons.push("verbessert die Stellung (Aktivität/Koordination)");
      }

      var piece=pieceNameDe(moveObj.piece);
      var core=reasons[0];
      var extra=reasons.slice(1,3);
      var tail=extra.length?(" ("+extra.join(", ")+")"):"";
      return colorName+" spielt "+piece+" von "+moveObj.from+" nach "+moveObj.to+", weil "+core+tail+".";
    }

    function describePvWhy(pvString,fen){
      if(!pvString)return"";
      var moves=pvString.trim().split(/\s+/);
      var temp;
      try{ temp=new Chess(fen); }catch(e){ return""; }
      var out=[];
      for(var i=0;i<moves.length;i++){
        var uci=moves[i];
        var s=describeOneMoveWhy(temp,uci);
        if(!s)break;
        out.push(s);
        if(out.length>=6)break;
      }
      return out.join(" ");
    }

    function handleInfoLine(line){
      var depthMatch=line.match(/\bdepth\s+(\d+)/);
      if(depthMatch)$("#depthValue").text(depthMatch[1]);

      var scoreMatch=line.match(/\bscore\s+(cp|mate)\s+(-?\d+)/);
      if(scoreMatch){
        var type=scoreMatch[1];
        var rawValue=parseInt(scoreMatch[2],10);
        var fenRef=lastSearchFen||getCurrentFen();
        var parts=fenRef.trim().split(/\s+/);
        var side=parts.length>1?parts[1]:"w";
        var whiteValue=side==="b"?-rawValue:rawValue;
        var text;
        if(type==="cp") text=(whiteValue/100).toFixed(2);
        else text=whiteValue>0?"#"+Math.abs(whiteValue):"#-"+Math.abs(whiteValue);
        $("#scoreValue").text(text);
        updateEvalBarFromScore(type,whiteValue);
      }

      var pvIndex=line.indexOf(" pv ");
      if(pvIndex!==-1){
        var pvMoves=line.substring(pvIndex+4).trim();
        var fenRef2=lastSearchFen||getCurrentFen();
        var sanPv=convertPvToSan(pvMoves,fenRef2);
        $("#pvValue").text(sanPv||pvMoves);
        var desc=describePvWhy(pvMoves,fenRef2);
        $("#descriptionValue").text(desc);
      }
    }

    function configureEngineStrength(){
      if(!engine)return;
      var enabled=$("#eloEnable").is(":checked");
      var elo=parseInt($("#eloInput").val(),10);
      if(enabled && elo && elo>0){
        if(elo<600)elo=600;
        if(elo>3200)elo=3200;
        engine.postMessage("setoption name UCI_LimitStrength value true");
        engine.postMessage("setoption name UCI_Elo value "+elo);
      }else{
        engine.postMessage("setoption name UCI_LimitStrength value false");
      }
    }

    function makeBestMoveWithGame(best){
      if(!best||best.length<4||best==="0000"){
        $("#statusLine").text("No legal move found.");
        return;
      }

      var from=best.slice(0,2);
      var to=best.slice(2,4);
      var promo=best.length>4?best.slice(4):undefined;

      var fenCurrent=$("#fenInput").val().trim()||getCurrentFen();
      var move=null,gameUsed=null;

      var g1=new Chess();
      if(g1.load(fenCurrent)){
        move=g1.move({from:from,to:to,promotion:promo||"q"});
        if(move)gameUsed=g1;
      }

      if(!move && lastSearchFen && lastSearchFen!==fenCurrent){
        var g2=new Chess();
        if(g2.load(lastSearchFen)){
          var move2=g2.move({from:from,to:to,promotion:promo||"q"});
          if(move2){ move=move2; gameUsed=g2; }
        }
      }

      if(move && gameUsed){
        var newFen=gameUsed.fen();
        if(!isAutoSwitchEnabled()){
          var parts=newFen.split(" ");
          parts[1]=getSideFromControls();
          newFen=parts.join(" ");
        }
        loadFenIntoBoardAndControls(newFen);
        highlightMove(from,to);
        return;
      }

      var pos=board.position();
      var moving=pos[from];
      if(!moving){
        $("#statusLine").text("Engine move could not be applied.");
        return;
      }

      delete pos[from];
      if(promo){
        var color=moving.charAt(0);
        pos[to]=color+promo.toUpperCase();
      }else{
        pos[to]=moving;
      }
      board.position(pos);

      if(isAutoSwitchEnabled()){
        var side=getSideFromControls();
        if(side==="w")$("#sideBlack").prop("checked",true);
        else $("#sideWhite").prop("checked",true);
      }

      syncFenInputFromBoard();
      highlightMove(from,to);
      $("#statusLine").text("Move applied directly on board.");
    }

    function handleBestMoveLine(line){
      isCalculating=false;
      $("#btnCalculate").prop("disabled",false);
      $("#statusLine").text("");

      var parts=line.split(" ");
      if(parts.length<2){
        $("#bestMoveValue").text("(none)");
        return;
      }

      var best=parts[1];
      if(best==="(none)"||best==="0000"){
        $("#bestMoveValue").text("(none)");
        return;
      }

      $("#bestMoveValue").text(best);

      var from=best.slice(0,2),to=best.slice(2,4);
      var mode=$("input[name='mode']:checked").val()||"show";

      if(mode==="make"){
        clearHighlights();
        makeBestMoveWithGame(best);
      }else{
        highlightMove(from,to);
      }
    }

    function initEngine(){
      engine=new Worker("stockfish.js");
      engine.onmessage=function(event){
        var line=typeof event.data==="string"?event.data:event;
        if(!line)return;
        if(line.startsWith("info "))handleInfoLine(line);
        else if(line.startsWith("bestmove"))handleBestMoveLine(line);
      };
      engine.postMessage("uci");
      configureEngineStrength();
    }

    function initBoard(){
      board=Chessboard("board",{
        draggable:true,
        position:"start",
        sparePieces:true,
        dropOffBoard:"trash",
        moveSpeed:"fast",
        snapSpeed:"fast",
        snapbackSpeed:"fast",
        pieceTheme:function(piece){return pieceImages[piece]||"";},
        onDrop:function(source,target,piece,newPos,oldPos){
          if(!isAutoSwitchEnabled()){
            shouldToggleAfterSnap=false;
            return;
          }
          if(JSON.stringify(newPos)!==JSON.stringify(oldPos)){
            shouldToggleAfterSnap=true;
          }else{
            shouldToggleAfterSnap=false;
          }
        },
        onSnapEnd:function(){
          if(shouldToggleAfterSnap){
            var side=getSideFromControls();
            if(side==="w")$("#sideBlack").prop("checked",true);
            else $("#sideWhite").prop("checked",true);
            shouldToggleAfterSnap=false;
          }
          syncFenInputFromBoard();
        }
      });

      $("#sideWhite").prop("checked",true);
      $("#castleWK").prop("checked",true);
      $("#castleWQ").prop("checked",true);
      $("#castleBK").prop("checked",true);
      $("#castleBQ").prop("checked",true);
      $("#autoSwitch").prop("checked",true);
      $("#eloEnable").prop("checked",false);
      syncFenInputFromBoard();
      setEvalBar(50);
    }

    $(function(){
      initBoard();
      initEngine();

      $("#btnStart").on("click",function(){
        board.start();
        $("#sideWhite").prop("checked",true);
        $("#castleWK").prop("checked",true);
        $("#castleWQ").prop("checked",true);
        $("#castleBK").prop("checked",true);
        $("#castleBQ").prop("checked",true);
        clearHighlights();
        syncFenInputFromBoard();
        setEvalBar(50);
        $("#statusLine").text("");
        $("#descriptionValue").text("");
        $("#pvValue").text("");
        $("#bestMoveValue").text("");
        $("#scoreValue").text("");
        $("#depthValue").text("");
      });

      $("#btnClear").on("click",function(){
        board.position({});
        clearHighlights();
        $("#sideWhite").prop("checked",true);
        $("#castleWK").prop("checked",false);
        $("#castleWQ").prop("checked",false);
        $("#castleBK").prop("checked",false);
        $("#castleBQ").prop("checked",false);
        syncFenInputFromBoard();
        setEvalBar(50);
        $("#statusLine").text("");
        $("#descriptionValue").text("");
        $("#pvValue").text("");
        $("#bestMoveValue").text("");
        $("#scoreValue").text("");
        $("#depthValue").text("");
      });

      $("#btnFlip").on("click",function(){board.flip();});

      $("#btnSetFen").on("click",function(){
        var fen=$("#fenInput").val().trim();
        if(!fen)return;
        if(!loadFenIntoBoardAndControls(fen)){
          $("#statusLine").text("Invalid FEN string.");
        }else{
          clearHighlights();
          setEvalBar(50);
          $("#statusLine").text("");
          $("#descriptionValue").text("");
          $("#pvValue").text("");
          $("#bestMoveValue").text("");
          $("#scoreValue").text("");
          $("#depthValue").text("");
        }
      });

      $("#sideWhite,#sideBlack").on("change",function(){syncFenInputFromBoard();});
      $("#castleWK,#castleWQ,#castleBK,#castleBQ").on("change",function(){syncFenInputFromBoard();});

      $("#eloEnable,#eloInput").on("change",function(){
        configureEngineStrength();
      });

      $("#btnCalculate").on("click",function(){
        if(isCalculating)return;

        var fen=$("#fenInput").val().trim();
        if(!fen)fen=getCurrentFen();

        var tmp=new Chess();
        if(!tmp.load(fen)){
          $("#statusLine").text("Invalid FEN, cannot calculate.");
          return;
        }

        var canonicalFen=tmp.fen();
        $("#fenInput").val(canonicalFen);
        setControlsFromFen(canonicalFen);
        lastSearchFen=canonicalFen;

        var timeSec=parseFloat($("#timeInput").val());
        if(!timeSec||timeSec<=0)timeSec=1;
        var timeMs=Math.round(timeSec*1000);

        isCalculating=true;
        $("#btnCalculate").prop("disabled",true);
        $("#statusLine").text("Engine thinking...");
        $("#scoreValue").text("");
        $("#depthValue").text("");
        $("#pvValue").text("");
        $("#bestMoveValue").text("");
        $("#descriptionValue").text("");
        clearHighlights();

        engine.postMessage("stop");
        configureEngineStrength();
        engine.postMessage("ucinewgame");
        engine.postMessage("position fen "+canonicalFen);
        engine.postMessage("go movetime "+timeMs);
      });
    });
  </script>
</body>
</html>
